"""
GRUB Bootloader Configuration Manager
Handles GRUB installation and configuration for multi-boot systems
"""

import os
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum

from .models import DeploymentRecipe, PartitionInfo, FileSystem


class GRUBBootMode(Enum):
    """GRUB boot modes"""
    UEFI = "uefi"
    LEGACY_BIOS = "bios"
    HYBRID = "hybrid"


@dataclass
class OSEntry:
    """Operating system entry for GRUB menu"""
    name: str
    os_type: str  # "windows", "macos", "linux", "custom"
    partition_uuid: str
    kernel_path: Optional[str] = None
    initrd_path: Optional[str] = None
    boot_params: List[str] = field(default_factory=list)
    chainload_path: Optional[str] = None
    icon_path: Optional[str] = None
    description: str = ""
    
    def to_grub_entry(self) -> str:
        """Generate GRUB menu entry"""
        entry_lines = [
            f'menuentry "{self.name}" {{',
        ]
        
        if self.description:
            entry_lines.append(f'    # {self.description}')
        
        # Set partition
        entry_lines.append(f'    set root=(hd0,gpt{self._get_partition_number()})')
        
        if self.os_type == "windows":
            # Windows chainload entry (correct path for installer media)
            entry_lines.extend([
                f'    insmod part_gpt',
                f'    insmod fat',
                f'    insmod ntfs',
                f'    insmod chain',
                f'    search --fs-uuid --set=root {self.partition_uuid}',
                f'    chainloader /EFI/BOOT/BOOTX64.EFI'
            ])
        elif self.os_type == "macos":
            # macOS chainload entry with APFS support
            entry_lines.extend([
                f'    insmod part_gpt',
                f'    insmod hfsplus',
                f'    insmod apfs',
                f'    insmod chain',
                f'    search --fs-uuid --set=root {self.partition_uuid}',
                f'    chainloader /System/Library/CoreServices/boot.efi'
            ])
        elif self.os_type == "linux":
            # Linux chainload to installer EFI (more reliable than direct boot)
            entry_lines.extend([
                f'    insmod part_gpt',
                f'    insmod ext2',
                f'    insmod fat',
                f'    search --fs-uuid --set=root {self.partition_uuid}',
                f'    chainloader /EFI/BOOT/BOOTX64.EFI'
            ])
        else:
            # Custom chainload
            if self.chainload_path:
                entry_lines.extend([
                    f'    insmod part_gpt',
                    f'    insmod fat',
                    f'    chainloader {self.chainload_path}'
                ])
        
        entry_lines.append('}')
        return '\n'.join(entry_lines)
    
    def _get_partition_number(self) -> int:
        """Get partition number from UUID (simplified)"""
        # In real implementation, this would query the partition table
        # For now, return a default based on OS type
        os_partition_map = {
            "windows": 4,  # Windows Installer partition
            "macos": 3,    # macOS Installer partition  
            "linux": 5,    # Linux Installer partition
        }
        return os_partition_map.get(self.os_type, 1)


@dataclass
class GRUBConfig:
    """GRUB configuration settings"""
    timeout: int = 10
    default_entry: int = 0
    theme: Optional[str] = None
    background: Optional[str] = None
    resolution: str = "auto"
    boot_mode: GRUBBootMode = GRUBBootMode.UEFI
    entries: List[OSEntry] = field(default_factory=list)
    additional_modules: List[str] = field(default_factory=list)
    
    def generate_config(self) -> str:
        """Generate complete GRUB configuration"""
        config_lines = [
            "# GRUB Configuration - Generated by BootForge",
            "# Multi-Boot System Configuration",
            "",
            "# Global settings",
            f"set timeout={self.timeout}",
            f"set default={self.default_entry}",
            "",
            "# Load required modules",
            "insmod part_gpt",
            "insmod part_msdos", 
            "insmod fat",
            "insmod ext2",
            "insmod ntfs",
            "insmod hfsplus",
            "insmod apfs",
            "insmod iso9660",
            "insmod configfile",
            "insmod normal",
            "insmod chain",
            "insmod multiboot",
            "insmod multiboot2",
            "insmod search",
            "insmod search_fs_uuid",
            "insmod probe",
        ]
        
        # Add additional modules
        for module in self.additional_modules:
            config_lines.append(f"insmod {module}")
        
        config_lines.extend([
            "",
            "# Graphics and theme settings",
            f"set gfxmode={self.resolution}",
            "terminal_output gfxterm",
        ])
        
        if self.theme:
            config_lines.append(f"set theme={self.theme}")
        
        if self.background:
            config_lines.append(f"background_image {self.background}")
        
        config_lines.extend([
            "",
            "# Operating System Entries",
            ""
        ])
        
        # Add OS entries
        for entry in self.entries:
            config_lines.append(entry.to_grub_entry())
            config_lines.append("")
        
        # Add advanced options
        config_lines.extend([
            '# Advanced Options',
            'submenu "Advanced options" {',
            '    menuentry "Memory Test (memtest86+)" {',
            '        linux16 /boot/memtest86+.bin',
            '    }',
            '    menuentry "Hardware Detection Tool" {',
            '        linux /boot/hdt.c32',
            '    }',
            '    menuentry "Boot from Hard Drive" {',
            '        set root=(hd1)',
            '        chainloader +1',
            '    }',
            '    menuentry "UEFI Firmware Settings" {',
            '        fwsetup',
            '    }',
            '}',
            ""
        ])
        
        return '\n'.join(config_lines)


class GRUBManager:
    """Manages GRUB installation and configuration for multi-boot systems"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.grub_config = GRUBConfig()
        
    def detect_existing_os(self, device_path: str) -> List[OSEntry]:
        """Detect existing operating systems on the device"""
        detected_os = []
        
        try:
            # Use blkid to detect filesystems and labels
            result = subprocess.run(
                ['sudo', 'blkid', device_path + '*'],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if 'LABEL=' in line:
                        # Parse partition info
                        if 'Windows' in line or 'NTFS' in line:
                            detected_os.append(OSEntry(
                                name="Windows",
                                os_type="windows",
                                partition_uuid=self._extract_uuid(line),
                                description="Detected Windows installation"
                            ))
                        elif 'Linux' in line or 'ext' in line:
                            detected_os.append(OSEntry(
                                name="Linux",
                                os_type="linux", 
                                partition_uuid=self._extract_uuid(line),
                                description="Detected Linux installation"
                            ))
                        elif 'macOS' in line or 'hfs' in line:
                            detected_os.append(OSEntry(
                                name="macOS",
                                os_type="macos",
                                partition_uuid=self._extract_uuid(line),
                                description="Detected macOS installation"
                            ))
            
            self.logger.info(f"Detected {len(detected_os)} existing OS installations")
            return detected_os
            
        except Exception as e:
            self.logger.warning(f"Error detecting existing OS: {e}")
            return []
    
    def create_multiboot_config(self, recipe: DeploymentRecipe, 
                              device_path: str) -> GRUBConfig:
        """Create GRUB configuration for multi-boot recipe"""
        config = GRUBConfig()
        
        # Add default entries based on recipe partitions
        for i, partition in enumerate(recipe.partitions):
            if partition.name == "EFI System":
                continue  # Skip EFI partition
                
            if "macOS" in partition.name:
                config.entries.append(OSEntry(
                    name="macOS Installer",
                    os_type="macos",
                    partition_uuid=f"partition-{i}",
                    description="Install macOS with OpenCore Legacy Patcher"
                ))
            elif "Windows" in partition.name:
                config.entries.append(OSEntry(
                    name="Windows Installer", 
                    os_type="windows",
                    partition_uuid=f"partition-{i}",
                    description="Install Windows 11 (bypassed hardware requirements)"
                ))
            elif "Linux" in partition.name:
                config.entries.append(OSEntry(
                    name="Linux Installer",
                    os_type="linux",
                    partition_uuid=f"partition-{i}",
                    description="Install Linux distribution"
                ))
        
        # Add utility entries
        config.entries.append(OSEntry(
            name="Rescue System",
            os_type="custom",
            partition_uuid="rescue",
            chainload_path="/boot/rescue.img",
            description="Emergency rescue system"
        ))
        
        # Configure based on metadata
        if recipe.metadata:
            config.timeout = recipe.metadata.get("grub_timeout", 10)
            config.additional_modules.extend(
                recipe.metadata.get("grub_modules", [])
            )
        
        self.grub_config = config
        return config
    
    def install_grub(self, device_path: str, efi_path: str, 
                    boot_mode: GRUBBootMode = GRUBBootMode.UEFI) -> bool:
        """Install GRUB bootloader to device"""
        try:
            self.logger.info(f"Installing GRUB in {boot_mode.value} mode")
            
            if boot_mode == GRUBBootMode.UEFI:
                # UEFI GRUB installation
                cmd = [
                    'sudo', 'grub-install',
                    '--target=x86_64-efi',
                    f'--efi-directory={efi_path}',
                    '--bootloader-id=BootForge',
                    '--removable',  # For broader compatibility
                    device_path
                ]
            else:
                # Legacy BIOS installation
                cmd = [
                    'sudo', 'grub-install',
                    '--target=i386-pc',
                    device_path
                ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                self.logger.info("GRUB installation successful")
                return True
            else:
                self.logger.error(f"GRUB installation failed: {result.stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error installing GRUB: {e}")
            return False
    
    def write_config(self, config_path: str, config: Optional[GRUBConfig] = None) -> bool:
        """Write GRUB configuration to file"""
        try:
            if config is None:
                config = self.grub_config
            
            config_content = config.generate_config()
            
            with open(config_path, 'w') as f:
                f.write(config_content)
            
            self.logger.info(f"GRUB configuration written to {config_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error writing GRUB config: {e}")
            return False
    
    def update_grub(self) -> bool:
        """Update GRUB configuration"""
        try:
            result = subprocess.run(
                ['sudo', 'update-grub'],
                capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                self.logger.info("GRUB configuration updated successfully")
                return True
            else:
                self.logger.warning(f"GRUB update warning: {result.stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error updating GRUB: {e}")
            return False
    
    def _extract_uuid(self, blkid_line: str) -> str:
        """Extract UUID from blkid output line"""
        try:
            if 'UUID=' in blkid_line:
                start = blkid_line.find('UUID=') + 5
                end = blkid_line.find(' ', start)
                if end == -1:
                    end = len(blkid_line)
                return blkid_line[start:end].strip('"')
            return "unknown"
        except:
            return "unknown"
    
    def validate_grub_installation(self, device_path: str) -> bool:
        """Validate GRUB installation"""
        try:
            # Check if GRUB files exist
            grub_checks = [
                Path("/boot/grub/grub.cfg").exists(),
                Path("/boot/grub/grubenv").exists()
            ]
            
            if all(grub_checks):
                self.logger.info("GRUB installation validation successful")
                return True
            else:
                self.logger.warning("GRUB installation validation failed")
                return False
                
        except Exception as e:
            self.logger.error(f"Error validating GRUB installation: {e}")
            return False
    
    def add_os_entry(self, entry: OSEntry):
        """Add OS entry to GRUB configuration"""
        self.grub_config.entries.append(entry)
        self.logger.info(f"Added OS entry: {entry.name}")
    
    def remove_os_entry(self, entry_name: str):
        """Remove OS entry from GRUB configuration"""
        self.grub_config.entries = [
            entry for entry in self.grub_config.entries
            if entry.name != entry_name
        ]
        self.logger.info(f"Removed OS entry: {entry_name}")
    
    def get_grub_version(self) -> Optional[str]:
        """Get installed GRUB version"""
        try:
            result = subprocess.run(
                ['grub-install', '--version'],
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                return result.stdout.strip()
            return None
            
        except Exception:
            return None